# unity-docs
## Documentation for UNITY data flow and analysis 

To view documentation click on the files listed above. Please contribute any feedback that may be useful for future reference. Any issues, questions, querries can be raised by using the 'issues' tab at the top. This will open a discussion on that topic and will enable us to work towards a solution.

### Contents:
- UNITY data naming SOP
- Getting setup on Flywheel
- fw-gears (codebase for gears uploaded to Flywheel)
- fw-sdk (software developer toolkit): hopefully useful tools to push, pull, curate data through CLI


Additional Flywheel documentation can be found here:
https://docs.flywheel.io/

# UNITY Best Practices for Building a Docker Image for Flywheel Gears
Version: 1.0  
Date: 2024-11-18  

Creating a well-structured and reliable Docker image for Flywheel requires adherence to certain standards to ensure compatibility, maintainability, and reproducibility. Below are best practices for each aspect:

## 1. Consistent Folder Structure
Recommended Folder Layout

```bash
/gear/                   # Root of the gear structure
    ├── Dockerfile       # Docker image build instructions
    ├── manifest.json    # Flywheel gear manifest file
    ├── run.py           # Run script to execute the gear logic
    ├── utils/           # Utility functions for modularization
    ├── app/             # Input data folder (source input data)
        ├── main.py      # Main script to execute the gear
    ├── inputs/          # Input data folder (source input data)
    ├── work/            # Ephemeral data folder (used during development/testing)
    ├── outputs/         # Output data folder (contents saved back to Flwwheel)
    ├── tests/           # Unit and integration tests
    ├── LICENSE          # License for the gear
    ├── README.md        # Documentation for usage
    ├── requirements.txt # Python dependencies (if applicable)
    └── VERSION          # Version number for the gear

```

## 2. Output Naming Conventions

**File Naming:**
Use a clear and consistent naming scheme that includes:
- Subject/session identifiers
- Gear name
- Processing version
- File type  
  
Example: *sub-01_ses-01_flywheel-antsseg_v1.0_output.nii.gz*  

**Directory Structure for Outputs:**

Including main outputs (e.g., NIfTI files, CSVs) and derived reports (e.g., HTML, PDFs)
```bash
outputs/
    ├── sub-01_ses-01_flywheel-antsseg_v1.0_output.nii.gz
    ├── sub-01_ses-01_flywheel-antsseg_v1.0_report.html
    ├── sub-02_ses-01_flywheel-antsseg_v1.0_derivatives.csv
```

**Metadata:** 

Metadata should be inlcude in the gear run to provide information about the processing steps and outputs. The config options should be captured automatically. Logs will be provided by the gear runtime environment. 
Run labels can be added to provide additional information to make parsing output easier
- gear_name
- Timestamp

**Optional json file to describe the output files generated by the gear**
```json
{
  "subject_id": "sub-01",
  "session_id": "ses-01",
  "gear_name": "flywheel-antsseg",
  "version": "1.0",
  "output_files": [
    "sub-01_ses-01_flywheel-antsseg_v1.0_output.nii.gz"
  ]
}
```

## 3. Dockerfile Best Practices

**Base Image Selection:**

Use lightweight base images like python:3.10-slim or debian:bullseye-slim.
Always specify a specific version (avoid latest).
Efficient Layering:

Combine RUN commands to minimize the number of layers:

```dockerfile
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    libglib2.0-0 libsm6 libxext6 libxrender1 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

**Environment Variables:**

Set defaults for Flywheel paths:
```dockerfile
ENV FLYWHEEL /flywheel/v0
```

**Install Dependencies:**

Use requirements.txt or install directly:
```dockerfile
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
```

**Run Script:**

Copy the gear code into the image:
```dockerfile
COPY . $FLYWHEEL
WORKDIR $FLYWHEEL
CMD ["python", "run.py"]
```

## 4. Gear Versioning
Semantic Versioning (SemVer):

Use the format MAJOR.MINOR.PATCH.
MAJOR: Breaking changes (e.g., new parameters or outputs).
MINOR: Backward-compatible new features.
PATCH: Bug fixes or optimizations.
Example: 
```1.2.0```


**Manifest Version Sync:**
Ensure the version field in manifest.json matches the image tag version in the file.

If these are out of sync an error will be thrown when running gear upload
```bash
fw-beta gear build .
```

When pushing builds, should also sync version controlling with GitHub
```bash
git tag -a v1.2.0 -m "Release version 1.2.0"
git push origin v1.2.0
```
In Visual Studio Code, you can create a new tag by clicking on the version number in the bottom left corner and selecting "Create Tag".


## 5. Gear Manifest Configuration
Basic Fields:  
Include details of repository, author, and description.  
Fill out the manifest.json file thoroughly:
```json
{
  "name": "flywheel-antsseg",
  "label": "ANTs Segmentation Gear",
  "description": "Performs brain segmentation using ANTs.",
  "version": "1.2.0",
  "author": "Your Name",
  "source": "https://github.com/yourorg/flywheel-antsseg",
  "license": "MIT"
}
```

Inputs:

Define inputs clearly:

```json
"inputs": {
  "nifti": {
    "base": "file",
    "type": {
      "enum": ["nifti"]
    },
    "description": "Input NIfTI file."
  }
}
```
Config Options:

Include optional configuration parameters:
```json
"config": {
  "threshold": {
    "default": 0.5,
    "description": "Threshold value for segmentation."
  }
}
```
Outputs:

Define output file types and descriptions:
```json
"outputs": {
  "segmentation": {
    "base": "file",
    "type": {
      "enum": ["nifti"]
    },
    "description": "Segmented brain output."
  }
}
```

## 6. Labels for Gears
Labels help categorize and retrieve gear results easily on Flywheel. Ensure these are included in the manifest.json file:

Example labels:
```json
"labels": ["segmentation", "MRI", "ANTs", "brain"]
```

## 7. Testing the Gear
Unit Tests:

Write unit tests for modular functions in /tests/.
Integration Tests:

Test the full gear locally:
```bash
docker run --rm -v /path/to/input:/flywheel/v0/input -v /path/to/output:/flywheel/v0/output mygear:1.2.0
```
Continuous Integration:

Use GitHub Actions or similar tools to automate testing.

## 8. Quality Assurance Checklist
Before deploying the gear:

Validation: Run against multiple test datasets to ensure consistent outputs.
Documentation: Update README.md with usage examples.
By adhering to these practices, your Flywheel gear will be reliable, maintainable, and user-friendly for the wider research community.


---

# Code Organization and Version Control with GitHub

Repository Structure
1.	Follow recomendation for Gear
```bash
/gear/                   # Root of the gear structure
    ├── Dockerfile       # Docker image build instructions
    ├── manifest.json    # Flywheel gear manifest file
    ├── run.py           # Run script to execute the gear logic
    ├── utils/           # Utility functions for modularization
    ├── app/             # Input data folder (source input data)
        ├── main.py      # Main script to execute the gear
    ├── inputs/          # Input data folder (source input data)
    ├── work/            # Ephemeral data folder (used during development/testing)
    ├── outputs/         # Output data folder (contents saved back to Flwwheel)
    ├── tests/           # Unit and integration tests
    ├── LICENSE          # License for the gear
    ├── README.md        # Documentation for usage
    ├── requirements.txt # Python dependencies (if applicable)
    └── VERSION          # Version number for the gear

```

**Branching Strategy:**
- Use a main branch for production code.  
- Use feature branches (e.g., feature/new_analysis) for development.  
- Implement a pull-request review process for merging.  

**Collaboration Best Practices**
- Use GitHub Issues to track bugs, tasks, and enhancements.
- Use milestones and projects to coordinate across groups.
- Write modular and reusable code to minimize duplication.
- Resuable functions for a gear should be /utils folder
- Use proper documentation for every shared function (e.g., docstrings, README files).


# Collaboration Under Dev Teams Practices
- Defined Roles and Responsibilities:
- Review contributions, and ensure adherence to coding standards.
- Analysis Teams (sites) implement pipelines and provide feedback to the Dev Team.
- Include technical deep-dives monthly to review shared code updates.
- Maintain a shared Confluence/Wiki to centralize best practices, FAQs, and troubleshooting guides.

### General Best Practices
•	Adhere to FAIR principles (Findable, Accessible, Interoperable, Reusable).
•	Always test and validate pipelines before deploying to partner sites.
•	Encourage feedback and collaboration across all teams to foster innovation.

### Partner Site Communication Practices
Unified Messaging:
- Prepare standardized training materials and documentation for data collection protocols.
  
Regular Updates:
- Schedule quarterly check-ins to review data quality, protocol adherence, and challenges.
 
Feedback Mechanism:
- Create a structured feedback loop, including a Google Form or Flywheel Notes, for site coordinators to report issues.


---

# Quality Control (QC) Practices
1.	Flywheel-Based QC Forms:
- Design QC forms within Flywheel for easy annotation of data issues.
- Train team members to complete forms after data uploads.
2.	Automated Phantom QA Pipelines:
- Implement automated processing of phantom imaging data to detect environment or scanner harware issues.
- Use QA dashboards for visual inspection of critical metrics (e.g., SNR, head motion).
3.	QC Workflow:
- Perform tiered reviews:
    - Tier 1: Visual inspection of raw data by researchers.
    - Tier 2: Visual inspection of processed data by analysts.
    - Tier 3: Outlier detection from derivatives.
Document QC results in a standardized format (e.g., CSV or Flywheel QC notes).
